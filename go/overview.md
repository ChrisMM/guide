# Originate Guides - Go - Overview

_Bad programmers create complicated solutions for simple problems.
Good programmers create complex solutions for complex problems.
Geniuses create simple solutions for complex problems._

Go is an ingeniously simple solution
for the many complex problems encountered in
large-scale, long-term, high-velocity software engineering.
Very often the velocity in such environments approximates zero
because of exponentially growing complexity, technical drift, compile times, and bit rot.
The genius underlying Go's simplicity isn't immediately obvious,
but is often confused for crudeness.
Nonetheless, while many languages add complexity for the sake of feature richness
and winning in code golf competitions,
Go addresses most of the issues found in large real-world software engineering projects
better than all other languages:
- slow builds (hours)
- each programmer uses a different subset of the language
- poor understandability of the code base (hard to read, poorly documented, etc)
- cost of updates (to the point of impossibility)
- accumulating technical drift
- not enough automated tools available
- turnover (people who wrote most of the code leave the team at some point,
  others have to take over)
